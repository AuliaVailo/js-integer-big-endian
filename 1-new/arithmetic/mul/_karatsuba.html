<!DOCTYPE html><html lang="en"><head><title>1-new/arithmetic/mul/_karatsuba</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../"><meta name="groc-document-path" content="1-new/arithmetic/mul/_karatsuba"><meta name="groc-project-path" content="js/src/1-new/arithmetic/mul/_karatsuba.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-integer-big-endian"><link rel="stylesheet" type="text/css" media="all" href="../../../assets/style.css"><script type="text/javascript" src="../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-integer-big-endian/blob/master/js/src/1-new/arithmetic/mul/_karatsuba.js">js/src/1-new/arithmetic/mul/_karatsuba.js</a></div></div><div id="document"><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Multiply two big endian arrays using karatsuba algorithm,
|A| &gt;= |B| &gt; 0, |C| &gt;= 2 * |A|, |A| &gt; 1.</p>
<p>/!\ BLOCK MULTIPLICATION RESULT MUST HOLD IN THE JAVASCRIPT NUMBER TYPE
    (DOUBLE i.e. 53 bits)</p>
<p>EXPLANATION</p>
<h6 id="">#</h6>
<p>We consider the numbers a and b, both of size N = 2n.</p>
<p>We divide a and b into their lower and upper parts.</p>
<p>a = a1 r^{n} + a0 (1)
b = b1 r^{n} + b0 (2)</p>
<p>We express the product of a and b using their lower and upper parts.</p>
<p>a b = (a1 r^{n} + a0) (b1 r^{n} + b0) (3)
    = a1 b1 r^{2n} + (a1 b0 + a0 b1) r^{n} + a0 b0 (4)</p>
<p>This gives us 4 multiplications with operands of size n.
Using a simple trick, we can reduce this computation to 3 multiplications.</p>
<p>We give the 3 terms of (4) the names z0, z1 and z2.</p>
<p>z2 = a1 b1
z1 = a1 b0 + a0 b1
z0 = a0 b0</p>
<p>a b  = z2 r^{2n} + z1 r^{n} + z0</p>
<p>We then express z1 using z0, z2 and one additional multiplication.</p>
<p>(a1 + a0)(b1 + b0) = a1 b1 + a0 b0 + (a1 b0 + a0 b1)
                   = z2 + z0 + z1</p>
<p>z1 = (a1 + a0)(b1 + b0) - z2 - z0</p>
<p>AN ANOTHER WAY AROUND (not used here)</p>
<p>(a1 - a0)(b1 - b0) = (a1 b1 + a0 b0) - (a1 b0 + a0 b1)
(a0 - a1)(b1 - b0) = (a1 b0 + a0 b1) - (a1 b1 + a0 b0)
a b = (r^{2n} + r^{n})a1 b1 + r^{n}(a0 - a1)(b1 - b0) + (r^{n} + 1)a0 b0</p>
<p>This algorithm is a specific case of the Toom-Cook algorithm, when m = n =
2.</p>
<p>For further reference, see</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Karatsuba_algorithm">http://en.wikipedia.org/wiki/Karatsuba_algorithm</a></li>
<li><a href="http://en.wikipedia.org/wiki/Toom–Cook_multiplication">http://en.wikipedia.org/wiki/Toom–Cook_multiplication</a></li>
</ul>
<p>Parameters:</p>
<ul>
<li><p><strong>r must be a Number.</strong><br/>(base (radix))</p>
</li>
<li><p><strong>a must be an Array.</strong><br/>(first operand)</p>
</li>
<li><p><strong>ai must be a Number.</strong><br/>(a left)</p>
</li>
<li><p><strong>aj must be a Number.</strong><br/>(a right)</p>
</li>
<li><p><strong>b must be an Array.</strong><br/>(second operand)</p>
</li>
<li><p><strong>bi must be a Number.</strong><br/>(b left)</p>
</li>
<li><p><strong>bj must be a Number.</strong><br/>(b right)</p>
</li>
<li><p><strong>c must be an Array.</strong><br/>(result, must be 0 initialized)</p>
</li>
<li><p><strong>ci must be a Number.</strong><br/>(c left)</p>
</li>
<li><p><strong>cj must be a Number.</strong><br/>(c right)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> _karatsuba = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> r , a , ai , aj , b , bi , bj , c , ci , cj </span>) </span>{

	<span class="hljs-keyword">const</span> i = aj - ai ;
	<span class="hljs-keyword">const</span> j = bj - bi ;
	<span class="hljs-keyword">const</span> k = cj - ci ;

	<span class="hljs-keyword">const</span> n  = <span class="hljs-built_in">Math</span>.ceil( i / <span class="hljs-number">2</span> ) ;
	<span class="hljs-keyword">const</span> I  = i + j ;
	<span class="hljs-keyword">const</span> N  = <span class="hljs-number">2</span> * n ;
	<span class="hljs-keyword">const</span> N_ = I - N ;
	<span class="hljs-keyword">const</span> i_ = aj - n ;
	<span class="hljs-keyword">const</span> j_ = <span class="hljs-built_in">Math</span>.max( bi , bj - n ) ;

	<span class="hljs-keyword">const</span> t1 = _zeros( n + <span class="hljs-number">1</span> ) ; <span class="hljs-comment">// + 1 to handle addition overflows</span>
	<span class="hljs-keyword">const</span> t2 = _zeros( n + <span class="hljs-number">1</span> ) ; <span class="hljs-comment">// and guarantee reducing k for the</span>
	<span class="hljs-keyword">const</span> t3 = _zeros( N + <span class="hljs-number">1</span> ) ; <span class="hljs-comment">// recursive calls</span>
	<span class="hljs-keyword">const</span> z2 = _zeros( N_ ) ;
	<span class="hljs-keyword">const</span> z0 = _zeros( N ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>RECURSIVE CALLS</p></div></div><div class="code"><div class="wrapper">	_mul( r , a , ai , i_ , b , bi , j_ , z2 , <span class="hljs-number">0</span> , N_ ) ;            <span class="hljs-comment">// z2 = a1.b1</span>
	_mul( r , a , i_ , aj , b , j_ , bj , z0 , <span class="hljs-number">0</span> , N ) ;             <span class="hljs-comment">// z0 = a0.b0</span>
	_add( r , a , ai , i_ , a , i_ , aj , t1 , <span class="hljs-number">0</span> , n + <span class="hljs-number">1</span> ) ;         <span class="hljs-comment">// (a0 + a1)</span>
	_add( r , b , bi , j_ , b , j_ , bj , t2 , <span class="hljs-number">0</span> , n + <span class="hljs-number">1</span> ) ;         <span class="hljs-comment">// (b1 + b0)</span>
	_mul( r , t1 , <span class="hljs-number">1</span> , n + <span class="hljs-number">1</span> , t2 , <span class="hljs-number">1</span> , n + <span class="hljs-number">1</span> , t3 , <span class="hljs-number">1</span> , N + <span class="hljs-number">1</span> ) ;   <span class="hljs-comment">// (a0 + a1)(b1 + b0)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>BUILD OUTPUT</p></div></div><div class="code"><div class="wrapper">	_copy( z2 , <span class="hljs-number">0</span> , N_ , c , cj - I ) ; <span class="hljs-comment">// + z2 . r^{2n}</span>
	_copy( z0 , <span class="hljs-number">0</span> , N  , c , cj - N ) ; <span class="hljs-comment">// + z0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>overflow on t1, add t2 . r^{n}</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> ( t1[<span class="hljs-number">0</span>] ) _iadd( r , t3 , <span class="hljs-number">0</span> , n + <span class="hljs-number">1</span> , t2 , <span class="hljs-number">0</span> , n + <span class="hljs-number">1</span> ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>overflow on t2, add t1 . r^{n} (except t1[0])</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> ( t2[<span class="hljs-number">0</span>] ) _iadd( r , t3 , <span class="hljs-number">0</span> , n + <span class="hljs-number">1</span> , t1 , <span class="hljs-number">1</span> , n + <span class="hljs-number">1</span> ) ;

	_iadd( r , c , ci , cj - n , t3 , <span class="hljs-number">0</span> , N + <span class="hljs-number">1</span> ) ; <span class="hljs-comment">// + (a0 + a1)(b1 + b0) . r^{n}</span>
	_isub( r , c , ci , cj - n , z2 , <span class="hljs-number">0</span> , N_ ) ;    <span class="hljs-comment">// - z2 . r^{n}</span>
	_isub( r , c , ci , cj - n , z0 , <span class="hljs-number">0</span> , N ) ;     <span class="hljs-comment">// - z1 . r^{n}</span>

} ;


exports._karatsuba = _karatsuba ;</div></div></div></div></body></html>