'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports._dc_div = _dc_div;

var _array = require('../../array');

var _mul = require('../mul');

var _ = require('.');

var _compare = require('../../compare');

/**
 * Input
 * -----
 *  - No leading zeros
 *  - |A| = |C|
 *
 * References
 * ----------
 *   - https://gmplib.org/manual/Divide-and-Conquer-Division.html
 *
 */
function _dc_div(X, a, ai, aj, b, bi, bj, c, ci, cj) {

	// [BZ98] Fast Recursive Division

	var r = aj - ai;
	var s = bj - bi;

	if (r < s || r === s && (0, _compare._CMP_n)(a, ai, aj, b, bi) < 0) return;

	// shift to get n = 2^k for some k
	var _n = 1;

	while (_n < s) {
		_n <<= 1;
	}var n = _n;

	var shift = n - s;

	var x = b[bi];
	var _X = X / 2;
	var _normalize = x < _X;
	var z = Math.ceil(_X / x);

	var w = r + shift + (_normalize || a[ai] >= _X);
	var t = Math.ceil(w / n);
	var _ai = 0;
	var _aj = t * n; // + 1 if
	var _a = (0, _array._zeros)(_aj); // potential normalization overflow
	var _ak = _aj - shift - r; // or if A potentially bigger than B
	(0, _array._copy)(a, ai, aj, _a, _ak);

	var _bi = 0;
	var _bj = n;
	var _b = (0, _array._zeros)(n);
	(0, _array._copy)(b, bi, bj, _b, 0);

	if (_normalize) {

		(0, _mul._imul_limb)(X, z, _a, _ai, _aj);
		(0, _mul._imul_limb)(X, z, _b, _bi, _bj);
	}

	var _cj = _aj;
	var _c = (0, _array._zeros)(_cj);

	for (var i = 0; i < _aj - n; i += n) {

		(0, _._dc_div_21)(X, _a, i, i + (n << 1), _b, _bi, _bj, _c, i, i + (n << 1));
	}

	if (_normalize) {
		var p = (0, _._mod_limb)(X, z, _a, _ai, _ak);
		(0, _._div_limb_partial_fast)(X, p, z, _a, _ak, _aj - shift, a, ai, aj);
	} else {
		(0, _array._copy)(_a, _ak, _aj - shift, a, ai, aj);
	}

	(0, _array._copy)(_c, _cj - r, _cj, c, ci);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb3JlL2FyaXRobWV0aWMvZGl2L19kY19kaXYuanMiXSwibmFtZXMiOlsiX2RjX2RpdiIsIlgiLCJhIiwiYWkiLCJhaiIsImIiLCJiaSIsImJqIiwiYyIsImNpIiwiY2oiLCJyIiwicyIsIl9uIiwibiIsInNoaWZ0IiwieCIsIl9YIiwiX25vcm1hbGl6ZSIsInoiLCJNYXRoIiwiY2VpbCIsInciLCJ0IiwiX2FpIiwiX2FqIiwiX2EiLCJfYWsiLCJfYmkiLCJfYmoiLCJfYiIsIl9jaiIsIl9jIiwiaSIsInAiXSwibWFwcGluZ3MiOiI7Ozs7O1FBaUJnQkEsTyxHQUFBQSxPOztBQWpCaEI7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0E7Ozs7Ozs7Ozs7O0FBV08sU0FBU0EsT0FBVCxDQUFtQkMsQ0FBbkIsRUFBdUJDLENBQXZCLEVBQTJCQyxFQUEzQixFQUFnQ0MsRUFBaEMsRUFBcUNDLENBQXJDLEVBQXlDQyxFQUF6QyxFQUE4Q0MsRUFBOUMsRUFBbURDLENBQW5ELEVBQXVEQyxFQUF2RCxFQUE0REMsRUFBNUQsRUFBaUU7O0FBRXZFOztBQUVBLEtBQU1DLElBQUlQLEtBQUtELEVBQWY7QUFDQSxLQUFNUyxJQUFJTCxLQUFLRCxFQUFmOztBQUVBLEtBQUtLLElBQUlDLENBQUosSUFBU0QsTUFBTUMsQ0FBTixJQUFXLHFCQUFRVixDQUFSLEVBQVlDLEVBQVosRUFBaUJDLEVBQWpCLEVBQXNCQyxDQUF0QixFQUEwQkMsRUFBMUIsSUFBaUMsQ0FBMUQsRUFBOEQ7O0FBRTlEO0FBQ0EsS0FBSU8sS0FBSyxDQUFUOztBQUVBLFFBQVFBLEtBQU1ELENBQWQ7QUFBa0JDLFNBQU8sQ0FBUDtBQUFsQixFQUVBLElBQU1DLElBQUlELEVBQVY7O0FBRUEsS0FBTUUsUUFBUUQsSUFBSUYsQ0FBbEI7O0FBRUEsS0FBTUksSUFBSVgsRUFBRUMsRUFBRixDQUFWO0FBQ0EsS0FBTVcsS0FBS2hCLElBQUksQ0FBZjtBQUNBLEtBQU1pQixhQUFhRixJQUFJQyxFQUF2QjtBQUNBLEtBQU1FLElBQUlDLEtBQUtDLElBQUwsQ0FBV0osS0FBS0QsQ0FBaEIsQ0FBVjs7QUFFQSxLQUFNTSxJQUFJWCxJQUFJSSxLQUFKLElBQWNHLGNBQWNoQixFQUFFQyxFQUFGLEtBQVNjLEVBQXJDLENBQVY7QUFDQSxLQUFNTSxJQUFJSCxLQUFLQyxJQUFMLENBQVdDLElBQUlSLENBQWYsQ0FBVjtBQUNBLEtBQU1VLE1BQU0sQ0FBWjtBQUNBLEtBQU1DLE1BQU1GLElBQUlULENBQWhCLENBMUJ1RSxDQTBCeEM7QUFDL0IsS0FBTVksS0FBSyxtQkFBUUQsR0FBUixDQUFYLENBM0J1RSxDQTJCeEM7QUFDL0IsS0FBTUUsTUFBTUYsTUFBTVYsS0FBTixHQUFjSixDQUExQixDQTVCdUUsQ0E0QnhDO0FBQy9CLG1CQUFPVCxDQUFQLEVBQVdDLEVBQVgsRUFBZ0JDLEVBQWhCLEVBQXFCc0IsRUFBckIsRUFBMEJDLEdBQTFCOztBQUVBLEtBQU1DLE1BQU0sQ0FBWjtBQUNBLEtBQU1DLE1BQU1mLENBQVo7QUFDQSxLQUFNZ0IsS0FBSyxtQkFBUWhCLENBQVIsQ0FBWDtBQUNBLG1CQUFPVCxDQUFQLEVBQVdDLEVBQVgsRUFBZ0JDLEVBQWhCLEVBQXFCdUIsRUFBckIsRUFBMEIsQ0FBMUI7O0FBRUEsS0FBS1osVUFBTCxFQUFrQjs7QUFFakIsdUJBQVlqQixDQUFaLEVBQWdCa0IsQ0FBaEIsRUFBb0JPLEVBQXBCLEVBQXlCRixHQUF6QixFQUErQkMsR0FBL0I7QUFDQSx1QkFBWXhCLENBQVosRUFBZ0JrQixDQUFoQixFQUFvQlcsRUFBcEIsRUFBeUJGLEdBQXpCLEVBQStCQyxHQUEvQjtBQUVBOztBQUVELEtBQU1FLE1BQU1OLEdBQVo7QUFDQSxLQUFNTyxLQUFLLG1CQUFRRCxHQUFSLENBQVg7O0FBRUEsTUFBTSxJQUFJRSxJQUFJLENBQWQsRUFBa0JBLElBQUlSLE1BQU1YLENBQTVCLEVBQWdDbUIsS0FBS25CLENBQXJDLEVBQXlDOztBQUV4QyxvQkFBWWIsQ0FBWixFQUFnQnlCLEVBQWhCLEVBQXFCTyxDQUFyQixFQUF5QkEsS0FBTW5CLEtBQUssQ0FBWCxDQUF6QixFQUEwQ2dCLEVBQTFDLEVBQStDRixHQUEvQyxFQUFxREMsR0FBckQsRUFBMkRHLEVBQTNELEVBQWdFQyxDQUFoRSxFQUFvRUEsS0FBTW5CLEtBQUssQ0FBWCxDQUFwRTtBQUVBOztBQUVELEtBQUtJLFVBQUwsRUFBa0I7QUFDakIsTUFBTWdCLElBQUksaUJBQVdqQyxDQUFYLEVBQWVrQixDQUFmLEVBQW1CTyxFQUFuQixFQUF3QkYsR0FBeEIsRUFBOEJHLEdBQTlCLENBQVY7QUFDQSxnQ0FBd0IxQixDQUF4QixFQUE0QmlDLENBQTVCLEVBQWdDZixDQUFoQyxFQUFvQ08sRUFBcEMsRUFBeUNDLEdBQXpDLEVBQStDRixNQUFNVixLQUFyRCxFQUE2RGIsQ0FBN0QsRUFBaUVDLEVBQWpFLEVBQXNFQyxFQUF0RTtBQUNBLEVBSEQsTUFJSztBQUNKLG9CQUFPc0IsRUFBUCxFQUFZQyxHQUFaLEVBQWtCRixNQUFNVixLQUF4QixFQUFnQ2IsQ0FBaEMsRUFBb0NDLEVBQXBDLEVBQXlDQyxFQUF6QztBQUNBOztBQUVELG1CQUFPNEIsRUFBUCxFQUFZRCxNQUFNcEIsQ0FBbEIsRUFBc0JvQixHQUF0QixFQUE0QnZCLENBQTVCLEVBQWdDQyxFQUFoQztBQUVBIiwiZmlsZSI6Il9kY19kaXYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfemVyb3MgLCBfY29weSB9IGZyb20gJy4uLy4uL2FycmF5JyA7XG5pbXBvcnQgeyBfaW11bF9saW1iIH0gZnJvbSAnLi4vbXVsJyA7XG5pbXBvcnQgeyBfZGNfZGl2XzIxICwgX2Rpdl9saW1iX3BhcnRpYWxfZmFzdCAsIF9tb2RfbGltYiB9IGZyb20gJy4nIDtcbmltcG9ydCB7IF9DTVBfbiB9IGZyb20gJy4uLy4uL2NvbXBhcmUnIDtcblxuXG4vKipcbiAqIElucHV0XG4gKiAtLS0tLVxuICogIC0gTm8gbGVhZGluZyB6ZXJvc1xuICogIC0gfEF8ID0gfEN8XG4gKlxuICogUmVmZXJlbmNlc1xuICogLS0tLS0tLS0tLVxuICogICAtIGh0dHBzOi8vZ21wbGliLm9yZy9tYW51YWwvRGl2aWRlLWFuZC1Db25xdWVyLURpdmlzaW9uLmh0bWxcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGNfZGl2ICggWCAsIGEgLCBhaSAsIGFqICwgYiAsIGJpICwgYmogLCBjICwgY2kgLCBjaiApIHtcblxuXHQvLyBbQlo5OF0gRmFzdCBSZWN1cnNpdmUgRGl2aXNpb25cblxuXHRjb25zdCByID0gYWogLSBhaSA7XG5cdGNvbnN0IHMgPSBiaiAtIGJpIDtcblxuXHRpZiAoIHIgPCBzIHx8IHIgPT09IHMgJiYgX0NNUF9uKCBhICwgYWkgLCBhaiAsIGIgLCBiaSApIDwgMCApIHJldHVybiA7XG5cblx0Ly8gc2hpZnQgdG8gZ2V0IG4gPSAyXmsgZm9yIHNvbWUga1xuXHRsZXQgX24gPSAxIDtcblxuXHR3aGlsZSAoIF9uICA8IHMgKSBfbiA8PD0gMSA7XG5cblx0Y29uc3QgbiA9IF9uIDtcblxuXHRjb25zdCBzaGlmdCA9IG4gLSBzIDtcblxuXHRjb25zdCB4ID0gYltiaV0gO1xuXHRjb25zdCBfWCA9IFggLyAyIDtcblx0Y29uc3QgX25vcm1hbGl6ZSA9IHggPCBfWCA7XG5cdGNvbnN0IHogPSBNYXRoLmNlaWwoIF9YIC8geCApIDtcblxuXHRjb25zdCB3ID0gciArIHNoaWZ0ICsgKCBfbm9ybWFsaXplIHx8IGFbYWldID49IF9YICkgO1xuXHRjb25zdCB0ID0gTWF0aC5jZWlsKCB3IC8gbiApIDtcblx0Y29uc3QgX2FpID0gMCA7XG5cdGNvbnN0IF9haiA9IHQgKiBuIDsgICAgICAgICAgICAvLyArIDEgaWZcblx0Y29uc3QgX2EgPSBfemVyb3MoIF9haiApIDsgICAgIC8vIHBvdGVudGlhbCBub3JtYWxpemF0aW9uIG92ZXJmbG93XG5cdGNvbnN0IF9hayA9IF9haiAtIHNoaWZ0IC0gciA7ICAvLyBvciBpZiBBIHBvdGVudGlhbGx5IGJpZ2dlciB0aGFuIEJcblx0X2NvcHkoIGEgLCBhaSAsIGFqICwgX2EgLCBfYWsgKSA7XG5cblx0Y29uc3QgX2JpID0gMCA7XG5cdGNvbnN0IF9iaiA9IG4gO1xuXHRjb25zdCBfYiA9IF96ZXJvcyggbiApIDtcblx0X2NvcHkoIGIgLCBiaSAsIGJqICwgX2IgLCAwICkgO1xuXG5cdGlmICggX25vcm1hbGl6ZSApIHtcblxuXHRcdF9pbXVsX2xpbWIoIFggLCB6ICwgX2EgLCBfYWkgLCBfYWogKSA7XG5cdFx0X2ltdWxfbGltYiggWCAsIHogLCBfYiAsIF9iaSAsIF9iaiApIDtcblxuXHR9XG5cblx0Y29uc3QgX2NqID0gX2FqIDtcblx0Y29uc3QgX2MgPSBfemVyb3MoIF9jaiApIDtcblxuXHRmb3IgKCBsZXQgaSA9IDAgOyBpIDwgX2FqIC0gbiA7IGkgKz0gbiApIHtcblxuXHRcdF9kY19kaXZfMjEoIFggLCBfYSAsIGkgLCBpICsgKCBuIDw8IDEgKSAsIF9iICwgX2JpICwgX2JqICwgX2MgLCBpICwgaSArICggbiA8PCAxICkgKSA7XG5cblx0fVxuXG5cdGlmICggX25vcm1hbGl6ZSApIHtcblx0XHRjb25zdCBwID0gX21vZF9saW1iKCBYICwgeiAsIF9hICwgX2FpICwgX2FrICkgO1xuXHRcdF9kaXZfbGltYl9wYXJ0aWFsX2Zhc3QoIFggLCBwICwgeiAsIF9hICwgX2FrICwgX2FqIC0gc2hpZnQgLCBhICwgYWkgLCBhaiApIDtcblx0fVxuXHRlbHNlIHtcblx0XHRfY29weSggX2EgLCBfYWsgLCBfYWogLSBzaGlmdCAsIGEgLCBhaSAsIGFqICkgO1xuXHR9XG5cblx0X2NvcHkoIF9jICwgX2NqIC0gciAsIF9jaiAsIGMgLCBjaSApIDtcblxufVxuIl19